---
layout: base
title: Farming
description: Farming Game
permalink: /farming
Author: Zach & Ian
---

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Harvest Haven</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
<style>
  body {
    background-color: #f8f9fa;
    font-family: 'Arial', sans-serif;
  }
  #gameCanvas {
    border: 3px solid #495057;
    border-radius: 5px;
    background-color: #8b9d83;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    cursor: pointer;
  }
  .inventory-slot {
    width: 50px;
    height: 50px;
    border: 2px solid #6c757d;
    border-radius: 5px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    margin: 3px;
    background-color: #e9ecef;
    cursor: pointer;
    transition: all 0.2s;
  }
  .inventory-slot:hover {
    background-color: #dee2e6;
    transform: scale(1.05);
  }
  .selected-slot {
    border: 2px solid #0d6efd;
    background-color: #cfe2ff;
  }
  .card {
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
  }
  .card-header {
    font-weight: bold;
    background-color: #e9ecef;
  }
  .controls {
    background-color: #e9ecef;
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 20px;
  }
  .btn-sm {
    padding: 0.25rem 0.5rem;
    font-size: 0.875rem;
  }
  .modal-content {
    border-radius: 10px;
  }
  .merchant-item {
    transition: all 0.2s;
  }
  .merchant-item:hover {
    transform: translateY(-3px);
  }
</style>

<div class="container py-4">
  <div class="text-center mb-4">
    <h1 class="display-4">Harvest Haven</h1>
    <p class="lead">A Stardew Valley inspired farming adventure</p>
  </div>

  <div class="row">
    <div class="col-lg-8">
      <div class="controls mb-3">
        <h5>Controls</h5>
        <p>
          <strong>WASD</strong> to move |
          <strong>E</strong> or <strong>Click</strong> to interact |
          <strong>Click</strong> inventory items to select
        </p>
        <p>
          Interact with objects and the merchant by facing them and pressing <strong>E</strong> or <strong>clicking</strong> on them in the game area.
        </p>
      </div>
      <canvas id="gameCanvas" width="800" height="600" tabindex="0"></canvas>
    </div>
    <div class="col-lg-4">
      <div class="card mb-3">
        <div class="card-header d-flex justify-content-between align-items-center">
          <span>Player Inventory</span>
          <span class="badge bg-primary">10 slots</span>
        </div>
        <div class="card-body" id="inventory">
          <!-- Inventory slots will be generated by JS -->
        </div>
      </div>
      <div class="card mb-3">
        <div class="card-header">Stats</div>
        <div class="card-body">
          <p><strong>Coins:</strong> <span id="coins" class="badge bg-success">100</span></p>
          <p><strong>Day:</strong> <span id="day" class="badge bg-info">1</span></p>
          <p><strong>Time:</strong> <span id="time" class="badge bg-secondary">08:00</span></p>
        </div>
      </div>
      <div class="card">
        <div class="card-header">Current Tool</div>
        <div class="card-body">
          <p id="currentTool">None selected</p>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Merchant Modal -->
<div class="modal fade" id="merchantModal" tabindex="-1">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Merchant's Shop</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body">
        <div class="alert alert-info">
          "Hello farmer! What can I do for you today?"
        </div>
        <h6 class="mt-3 mb-2">Buy Items</h6>
        <div class="row" id="merchantItems">
          <!-- Merchant items will be populated by JS -->
        </div>
        
        <hr>
        
        <h6 class="mt-3 mb-2">Sell Items</h6>
        <div class="d-flex justify-content-between align-items-center mb-3">
          <div>
            <button class="btn btn-success sell-btn">Sell All Crops</button>
            <button class="btn btn-success sell-btn ms-2">Sell All Ores</button>
          </div>
          <div>
            <button class="btn btn-danger sell-btn">Sell Everything</button>
          </div>
        </div>
        <div id="sellPreview" class="bg-light p-2 rounded">
          <!-- Items to sell will appear here -->
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<script>
  // Game State
  const gameState = {
    player: {
      x: 400,
      y: 300,
      speed: 3,
      direction: 'down',
      inventory: [],
      coins: 100,
      selectedSlot: null,
      tools: {
        sickle: { name: 'Sickle', type: 'tool', uses: Infinity, action: 'harvest' },
        pickaxe: { name: 'Pickaxe', type: 'tool', uses: Infinity, action: 'mine' }
      }
    },
    map: {
      tiles: [],
      width: 80,
      height: 60,
      tileSize: 10,
      merchantPosition: { x: 10, y: 10 }
    },
    crops: [],
    ores: [],
    merchant: {
      items: [
        { name: 'Wheat Seed', type: 'seed', price: 10, rarity: 'common', growthTime: 3, produces: 'Wheat' },
        { name: 'Carrot Seed', type: 'seed', price: 20, rarity: 'uncommon', growthTime: 5, produces: 'Carrot' },
        { name: 'Pumpkin Seed', type: 'seed', price: 50, rarity: 'rare', growthTime: 8, produces: 'Pumpkin' },
        { name: 'Fertilizer', type: 'item', price: 30, effect: 'growthSpeed', value: 0.8 }
      ]
    },
    time: {
      day: 1,
      hour: 8,
      minute: 0,
      paused: false
    },
    keys: { w: false, a: false, s: false, d: false, e: false }
  };

  // DOM Elements
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const coinsDisplay = document.getElementById('coins');
  const dayDisplay = document.getElementById('day');
  const timeDisplay = document.getElementById('time');
  const inventoryDiv = document.getElementById('inventory');
  const currentToolDisplay = document.getElementById('currentTool');
  let merchantModal = null;

  // --- Helper: Get tile under pixel coordinates ---
  function getTileAtPixel(x, y) {
    return {
      tileX: Math.floor(x / gameState.map.tileSize),
      tileY: Math.floor(y / gameState.map.tileSize)
    };
  }

  // --- Helper: Get object at tile ---
  function getObjectAtTile(tileX, tileY) {
    // Merchant
    if (tileX === gameState.map.merchantPosition.x && tileY === gameState.map.merchantPosition.y) {
      return { type: 'merchant' };
    }
    // Crop
    const cropIndex = gameState.crops.findIndex(c =>
      Math.floor(c.x / gameState.map.tileSize) === tileX &&
      Math.floor(c.y / gameState.map.tileSize) === tileY
    );
    if (cropIndex !== -1) return { type: 'crop', index: cropIndex };
    // Ore
    const oreIndex = gameState.ores.findIndex(o =>
      Math.floor(o.x / gameState.map.tileSize) === tileX &&
      Math.floor(o.y / gameState.map.tileSize) === tileY
    );
    if (oreIndex !== -1) return { type: 'ore', index: oreIndex };
    // Tilled soil
    if (gameState.map.tiles[tileY] && gameState.map.tiles[tileY][tileX] === 'tilled_soil') {
      return { type: 'tilled_soil' };
    }
    return null;
  }

  // Initialize the game
  function initGame() {
    generateMap();
    generateOres();
    setupInventory();
    gameState.player.inventory.push(gameState.player.tools.sickle);
    gameState.player.inventory.push(gameState.player.tools.pickaxe);
    merchantModal = new bootstrap.Modal(document.getElementById('merchantModal'));
    setInterval(() => {
      if (!gameState.time.paused) {
        updateTime();
        updatePlayerPosition();
      }
      drawGame();
    }, 1000/60);
    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('keyup', handleKeyUp);
    // --- Add mouse click interaction on canvas ---
    canvas.addEventListener('click', handleCanvasClick);
    // --- Add hover effect for pointer cursor on interactive objects ---
    canvas.addEventListener('mousemove', handleCanvasHover);
    // --- Allow keyboard focus for accessibility ---
    canvas.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        interact();
      }
    });
    drawGame();
  }

  // --- Mouse click handler for easier interaction ---
  function handleCanvasClick(e) {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const { tileX, tileY } = getTileAtPixel(mouseX, mouseY);
    const obj = getObjectAtTile(tileX, tileY);

    if (!obj) return;

    if (obj.type === 'merchant') {
      openMerchant();
    } else if (obj.type === 'crop') {
      // Try to harvest crop
      harvestCrop(obj.index, true);
    } else if (obj.type === 'ore') {
      // Try to mine ore
      mineOre(obj.index, true);
    } else if (obj.type === 'tilled_soil') {
      // Try to plant seed
      plantCrop(tileX, tileY, getSelectedSeed());
    }
  }

  // --- Change cursor to pointer if hovering interactive object ---
  function handleCanvasHover(e) {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const { tileX, tileY } = getTileAtPixel(mouseX, mouseY);
    const obj = getObjectAtTile(tileX, tileY);
    if (obj) {
      canvas.style.cursor = 'pointer';
    } else {
      canvas.style.cursor = 'default';
    }
  }

  // --- Helper: Get selected seed from inventory ---
  function getSelectedSeed() {
    if (gameState.player.selectedSlot !== null) {
      const item = gameState.player.inventory[gameState.player.selectedSlot];
      if (item && item.type === 'seed') return item;
    }
    // If no seed selected, try to find first seed in inventory
    return gameState.player.inventory.find(item => item.type === 'seed');
  }

  // Map generation (unchanged)
  function generateMap() {
    for (let y = 0; y < gameState.map.height; y++) {
      gameState.map.tiles[y] = [];
      for (let x = 0; x < gameState.map.width; x++) {
        if (Math.random() < 0.1) {
          gameState.map.tiles[y][x] = 'water';
        } else if (Math.random() < 0.2) {
          gameState.map.tiles[y][x] = 'grass';
        } else {
          gameState.map.tiles[y][x] = 'dirt';
        }
      }
    }
    for (let y = 20; y < 30; y++) {
      for (let x = 30; x < 50; x++) {
        gameState.map.tiles[y][x] = 'tilled_soil';
      }
    }
    gameState.map.tiles[gameState.map.merchantPosition.y][gameState.map.merchantPosition.x] = 'dirt';
  }

  // Ore generation (unchanged)
  function generateOres() {
    gameState.ores = [];
    const oreTypes = [
      { name: 'Copper Ore', rarity: 'common', value: 20, spawnChance: 0.1 },
      { name: 'Iron Ore', rarity: 'uncommon', value: 50, spawnChance: 0.05 },
      { name: 'Gold Ore', rarity: 'rare', value: 100, spawnChance: 0.02 },
      { name: 'Diamond', rarity: 'legendary', value: 500, spawnChance: 0.005 }
    ];
    for (let y = 0; y < gameState.map.height; y++) {
      for (let x = 0; x < gameState.map.width; x++) {
        if (gameState.map.tiles[y][x] === 'dirt' || gameState.map.tiles[y][x] === 'grass') {
          for (const ore of oreTypes) {
            if (Math.random() < ore.spawnChance) {
              gameState.ores.push({
                x: x * gameState.map.tileSize,
                y: y * gameState.map.tileSize,
                type: ore.name,
                rarity: ore.rarity,
                value: ore.value
              });
              break;
            }
          }
        }
      }
    }
  }

  // Inventory management (unchanged)
  function setupInventory() {
    inventoryDiv.innerHTML = '';
    for (let i = 0; i < 10; i++) {
      const slot = document.createElement('div');
      slot.className = 'inventory-slot';
      slot.id = `slot-${i}`;
      slot.addEventListener('click', () => selectItem(i));
      if (gameState.player.inventory[i]) {
        slot.textContent = gameState.player.inventory[i].name.substring(0, 3);
        slot.title = gameState.player.inventory[i].name;
        if (i === gameState.player.selectedSlot) {
          slot.classList.add('selected-slot');
          if (gameState.player.inventory[i].type === 'tool') {
            currentToolDisplay.textContent = gameState.player.inventory[i].name;
          } else {
            currentToolDisplay.textContent = 'None selected';
          }
        }
      }
      inventoryDiv.appendChild(slot);
    }
    coinsDisplay.textContent = gameState.player.coins;
  }

  function selectItem(slotIndex) {
    gameState.player.selectedSlot = slotIndex;
    setupInventory();
  }

  // Time system (unchanged)
  function updateTime() {
    gameState.time.minute += 10;
    if (gameState.time.minute >= 60) {
      gameState.time.minute = 0;
      gameState.time.hour++;
      if (gameState.time.hour >= 24) {
        gameState.time.hour = 6;
        gameState.time.day++;
        updateCrops();
        if (Math.random() < 0.3) {
          generateOres();
        }
      }
    }
    const hourStr = gameState.time.hour.toString().padStart(2, '0');
    const minuteStr = gameState.time.minute.toString().padStart(2, '0');
    timeDisplay.textContent = `${hourStr}:${minuteStr}`;
    dayDisplay.textContent = gameState.time.day;
  }

  // Crop growth (unchanged)
  function updateCrops() {
    for (const crop of gameState.crops) {
      if (crop.growth < crop.growthTime) {
        crop.growth++;
        if (crop.growth === crop.growthTime) {
          crop.ready = true;
        }
      }
    }
  }

  // Drawing functions (unchanged)
  function drawGame() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let y = 0; y < gameState.map.height; y++) {
      for (let x = 0; x < gameState.map.width; x++) {
        const tileX = x * gameState.map.tileSize;
        const tileY = y * gameState.map.tileSize;
        switch (gameState.map.tiles[y][x]) {
          case 'water':
            ctx.fillStyle = '#4a8df0';
            break;
          case 'grass':
            ctx.fillStyle = '#5a9e4a';
            break;
          case 'tilled_soil':
            ctx.fillStyle = '#8b5a2b';
            break;
          default:
            ctx.fillStyle = '#a67c52';
        }
        ctx.fillRect(tileX, tileY, gameState.map.tileSize, gameState.map.tileSize);
      }
    }
    // Draw merchant
    const merchantX = gameState.map.merchantPosition.x * gameState.map.tileSize;
    const merchantY = gameState.map.merchantPosition.y * gameState.map.tileSize;
    ctx.fillStyle = '#007bff';
    ctx.fillRect(merchantX, merchantY, gameState.map.tileSize, gameState.map.tileSize);
    ctx.fillStyle = '#ffffff';
    ctx.font = '8px Arial';
    ctx.fillText('$', merchantX + 3, merchantY + gameState.map.tileSize - 3);
    // Draw ores
    for (const ore of gameState.ores) {
      ctx.fillStyle = getOreColor(ore.type);
      ctx.beginPath();
      ctx.arc(ore.x + gameState.map.tileSize/2, ore.y + gameState.map.tileSize/2, 
          gameState.map.tileSize/2, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#ffffff';
      ctx.font = '8px Arial';
      ctx.fillText(ore.value, ore.x + 2, ore.y + gameState.map.tileSize - 2);
    }
    // Draw crops
    for (const crop of gameState.crops) {
      if (crop.ready) {
        ctx.fillStyle = getCropColor(crop.type);
      } else {
        ctx.fillStyle = '#5a9e4a';
      }
      ctx.fillRect(crop.x, crop.y, gameState.map.tileSize, gameState.map.tileSize);
      if (!crop.ready) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(crop.x, crop.y + gameState.map.tileSize - 2, 
              gameState.map.tileSize * (crop.growth / crop.growthTime), 2);
      }
    }
    // Draw player
    ctx.fillStyle = '#dc3545';
    ctx.fillRect(gameState.player.x, gameState.player.y, 15, 15);
    ctx.fillStyle = '#ffffff';
    switch (gameState.player.direction) {
      case 'up':
        ctx.fillRect(gameState.player.x + 5, gameState.player.y, 5, 3);
        break;
      case 'down':
        ctx.fillRect(gameState.player.x + 5, gameState.player.y + 12, 5, 3);
        break;
      case 'left':
        ctx.fillRect(gameState.player.x, gameState.player.y + 5, 3, 5);
        break;
      case 'right':
        ctx.fillRect(gameState.player.x + 12, gameState.player.y + 5, 3, 5);
        break;
    }
  }

  function getOreColor(oreType) {
    switch (oreType) {
      case 'Copper Ore': return '#b87333';
      case 'Iron Ore': return '#a19d94';
      case 'Gold Ore': return '#ffd700';
      case 'Diamond': return '#b9f2ff';
      default: return '#ffffff';
    }
  }

  function getCropColor(cropType) {
    switch (cropType) {
      case 'Wheat': return '#f5deb3';
      case 'Carrot': return '#ffa500';
      case 'Pumpkin': return '#ff7518';
      default: return '#5a9e4a';
    }
  }

  // Input handling
  function handleKeyDown(e) {
    const key = e.key.toLowerCase();
    if (key in gameState.keys) {
      gameState.keys[key] = true;
      if (key === 'e') {
        interact();
      }
    }
  }

  function handleKeyUp(e) {
    const key = e.key.toLowerCase();
    if (key in gameState.keys) {
      gameState.keys[key] = false;
    }
  }

  function updatePlayerPosition() {
    if (gameState.keys.w) {
      gameState.player.y -= gameState.player.speed;
      gameState.player.direction = 'up';
    }
    if (gameState.keys.s) {
      gameState.player.y += gameState.player.speed;
      gameState.player.direction = 'down';
    }
    if (gameState.keys.a) {
      gameState.player.x -= gameState.player.speed;
      gameState.player.direction = 'left';
    }
    if (gameState.keys.d) {
      gameState.player.x += gameState.player.speed;
      gameState.player.direction = 'right';
    }
    gameState.player.x = Math.max(0, Math.min(canvas.width - 15, gameState.player.x));
    gameState.player.y = Math.max(0, Math.min(canvas.height - 15, gameState.player.y));
  }

  // --- Improved interact: also triggers on click, and highlights nearest object ---
  function interact() {
    // Get tile player is facing
    let tileX, tileY;
    switch (gameState.player.direction) {
      case 'up':
        tileX = Math.floor(gameState.player.x / gameState.map.tileSize);
        tileY = Math.floor((gameState.player.y - 10) / gameState.map.tileSize);
        break;
      case 'down':
        tileX = Math.floor(gameState.player.x / gameState.map.tileSize);
        tileY = Math.floor((gameState.player.y + 20) / gameState.map.tileSize);
        break;
      case 'left':
        tileX = Math.floor((gameState.player.x - 10) / gameState.map.tileSize);
        tileY = Math.floor(gameState.player.y / gameState.map.tileSize);
        break;
      case 'right':
        tileX = Math.floor((gameState.player.x + 20) / gameState.map.tileSize);
        tileY = Math.floor(gameState.player.y / gameState.map.tileSize);
        break;
    }
    const obj = getObjectAtTile(tileX, tileY);
    if (!obj) return;
    if (obj.type === 'merchant') {
      openMerchant();
      return;
    }
    if (obj.type === 'crop') {
      harvestCrop(obj.index, false);
      return;
    }
    if (obj.type === 'ore') {
      mineOre(obj.index, false);
      return;
    }
    if (obj.type === 'tilled_soil') {
      plantCrop(tileX, tileY, getSelectedSeed());
    }
  }

  // --- Allow click/keyboard harvest/mine to skip tool selection if possible ---
  function harvestCrop(index, viaClick = false) {
    const crop = gameState.crops[index];
    let selectedItem = gameState.player.selectedSlot !== null 
      ? gameState.player.inventory[gameState.player.selectedSlot] 
      : null;
    // If not sickle, but via click, auto-equip sickle if available
    if ((!selectedItem || selectedItem.name !== 'Sickle') && viaClick) {
      const sickleIndex = gameState.player.inventory.findIndex(i => i.name === 'Sickle');
      if (sickleIndex !== -1) {
        gameState.player.selectedSlot = sickleIndex;
        setupInventory();
        selectedItem = gameState.player.inventory[sickleIndex];
      }
    }
    const sickleEquipped = selectedItem && selectedItem.name === 'Sickle';
    if (sickleEquipped) {
      const harvestedItem = {
        name: crop.type,
        type: 'crop',
        value: getCropValue(crop.type)
      };
      if (gameState.player.inventory.length < 10) {
        gameState.player.inventory.push(harvestedItem);
        gameState.crops.splice(index, 1);
        setupInventory();
      } else {
        alert('Inventory full!');
      }
    } else {
      alert('You need to select the sickle to harvest!');
    }
  }

  function getCropValue(cropType) {
    const seed = gameState.merchant.items.find(item => 
      item.produces === cropType);
    return seed ? seed.price * 2 : 10;
  }

  function mineOre(index, viaClick = false) {
    const ore = gameState.ores[index];
    let selectedItem = gameState.player.selectedSlot !== null 
      ? gameState.player.inventory[gameState.player.selectedSlot] 
      : null;
    // If not pickaxe, but via click, auto-equip pickaxe if available
    if ((!selectedItem || selectedItem.name !== 'Pickaxe') && viaClick) {
      const pickaxeIndex = gameState.player.inventory.findIndex(i => i.name === 'Pickaxe');
      if (pickaxeIndex !== -1) {
        gameState.player.selectedSlot = pickaxeIndex;
        setupInventory();
        selectedItem = gameState.player.inventory[pickaxeIndex];
      }
    }
    const pickaxeEquipped = selectedItem && selectedItem.name === 'Pickaxe';
    if (pickaxeEquipped) {
      const oreItem = {
        name: ore.type,
        type: 'ore',
        value: ore.value
      };
      if (gameState.player.inventory.length < 10) {
        gameState.player.inventory.push(oreItem);
        gameState.ores.splice(index, 1);
        setupInventory();
      } else {
        alert('Inventory full!');
      }
    } else {
      alert('You need to select the pickaxe to mine!');
    }
  }

  function plantCrop(tileX, tileY, seed) {
    if (!seed) {
      alert('Select a seed in your inventory to plant!');
      return;
    }
    const seedIndex = gameState.player.inventory.indexOf(seed);
    if (seedIndex !== -1) {
      gameState.player.inventory.splice(seedIndex, 1);
      gameState.crops.push({
        x: tileX * gameState.map.tileSize,
        y: tileY * gameState.map.tileSize,
        type: seed.produces,
        growth: 0,
        growthTime: seed.growthTime,
        ready: false
      });
      setupInventory();
    }
  }

  function openMerchant() {
    const merchantItemsDiv = document.getElementById('merchantItems');
    merchantItemsDiv.innerHTML = '';
    gameState.merchant.items.forEach((item, index) => {
      const itemDiv = document.createElement('div');
      itemDiv.className = 'col-md-6 mb-3 merchant-item';
      itemDiv.innerHTML = `
        <div class="card h-100">
          <div class="card-body d-flex flex-column">
            <h5 class="card-title">${item.name}</h5>
            <p class="card-text">${getItemDescription(item)}</p>
            <div class="mt-auto d-flex justify-content-between align-items-center">
              <span class="badge bg-primary">${item.price} coins</span>
              <button class="btn btn-primary btn-sm buy-btn" data-index="${index}">Buy</button>
            </div>
          </div>
        </div>
      `;
      merchantItemsDiv.appendChild(itemDiv);
    });
    updateSellPreview();
    merchantModal.show();
    document.querySelectorAll('.buy-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const index = parseInt(e.target.getAttribute('data-index'));
        buyItem(index);
      });
    });
    document.querySelectorAll('.sell-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const action = e.target.textContent;
        if (action.includes('Crops')) {
          sellItems('crop');
        } else if (action.includes('Ores')) {
          sellItems('ore');
        } else {
          sellItems('all');
        }
      });
    });
  }

  function getItemDescription(item) {
    if (item.type === 'seed') {
      return `Grows into ${item.produces} in ${item.growthTime} days.`;
    } else if (item.type === 'item' && item.effect === 'growthSpeed') {
      return `Speeds up crop growth by ${(1 - item.value) * 100}%.`;
    }
    return '';
  }

  function updateSellPreview() {
    const sellPreview = document.getElementById('sellPreview');
    const crops = gameState.player.inventory.filter(item => item.type === 'crop');
    const ores = gameState.player.inventory.filter(item => item.type === 'ore');
    let previewHTML = '';
    if (crops.length > 0) {
      const cropValue = crops.reduce((sum, crop) => sum + crop.value, 0);
      previewHTML += `<p><strong>Crops:</strong> ${crops.length} items worth ${cropValue} coins</p>`;
    } else {
      previewHTML += `<p class="text-muted">No crops to sell</p>`;
    }
    if (ores.length > 0) {
      const oreValue = ores.reduce((sum, ore) => sum + ore.value, 0);
      previewHTML += `<p><strong>Ores:</strong> ${ores.length} items worth ${oreValue} coins</p>`;
    } else {
      previewHTML += `<p class="text-muted">No ores to sell</p>`;
    }
    sellPreview.innerHTML = previewHTML;
  }

  function buyItem(index) {
    const item = gameState.merchant.items[index];
    if (gameState.player.coins >= item.price) {
      if (gameState.player.inventory.length < 10) {
        gameState.player.coins -= item.price;
        gameState.player.inventory.push({...item});
        setupInventory();
        updateSellPreview();
      } else {
        alert('Inventory full!');
      }
    } else {
      alert('Not enough coins!');
    }
  }

  function sellItems(type) {
    let itemsToSell = [];
    let itemsToKeep = [];
    if (type === 'all') {
      itemsToSell = gameState.player.inventory.filter(item => item.type === 'crop' || item.type === 'ore');
      itemsToKeep = gameState.player.inventory.filter(item => item.type !== 'crop' && item.type !== 'ore');
    } else {
      itemsToSell = gameState.player.inventory.filter(item => item.type === type);
      itemsToKeep = gameState.player.inventory.filter(item => item.type !== type);
    }
    const total = itemsToSell.reduce((sum, item) => sum + item.value, 0);
    if (itemsToSell.length > 0) {
      gameState.player.inventory = itemsToKeep;
      gameState.player.coins += total;
      setupInventory();
      updateSellPreview();
      const feedback = document.createElement('div');
      feedback.className = 'alert alert-success mt-3';
      feedback.textContent = `Sold ${itemsToSell.length} items for ${total} coins!`;
      document.querySelector('.modal-body').prepend(feedback);
      setTimeout(() => feedback.remove(), 2000);
    } else {
      const feedback = document.createElement('div');
      feedback.className = 'alert alert-warning mt-3';
      feedback.textContent = `No items to sell!`;
      document.querySelector('.modal-body').prepend(feedback);
      setTimeout(() => feedback.remove(), 2000);
    }
  }

  window.onload = initGame;
</script>

<script>
// filepath: /home/kasm-user/nighthawk/GenomeGamersFrontend/navigation/Worlds/world0.md
// ...existing code...

// --- Background Music ---
const music = new Audio('{{site.baseurl}}/assets/audio/27mariocircuit.mp3'); // Change path as needed
music.loop = true;
music.volume = 0.5;

// Play music after first user interaction (required by browsers)
function startMusicOnce() {
  music.play().catch(() => {});
  window.removeEventListener('click', startMusicOnce);
  window.removeEventListener('keydown', startMusicOnce);
}
window.addEventListener('click', startMusicOnce);
window.addEventListener('keydown', startMusicOnce);
</script>
